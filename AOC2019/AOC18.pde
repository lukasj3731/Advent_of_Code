import java.util.*;

String in = "#################################################################################,#.......#...#...#...........#.....#...#.#.....#m......#.......#.....#........u..#,#####.#.#.#.#.#.###.#######.###.#.#.#.#.#.###.###.#####.#.###.###.#.###########.#,#.....#...#...#.....#.#.....#...#...#...#.#....e#.......#...#.....#.....#.......#,#.###################.#.#####.#########.#.#####.###########.###########.#.#######,#.#...#...#...........#.#.....#.......#.#.....#.....#.....#...#.......#.#.#.....#,#.#S#.###.#.#####.#####.#.###.#.###.###.#####.#####.#.###.###.#.#.#####.#.#.###.#,#.#.#...#.#...#.#.......#.#.#.#.#...#...#.D.#.#...#...#.#.#...#.#.#.....#j..#...#,#.#.###.#.###.#.#########.#.#.###.###.###.#.#.#.#.#####.#.#.###.###.#########.###,#.#...#.#...#...#.#.........#...#.#...#.#.#...#.#.....#...#...#...#.#.#.....#...#,#.###.#.###.###.#.#.#########.#.#.#.###.#.#####.#####.#.#####.###.#.#.#.#.#.###.#,#...#.#c..#.....#.......#...#.#.#.#.#...#...#.....#.#.#.#.....#...#.#...#.#...#.#,#.###.###.#.#############.#.###.#.#.#.#.###.#####.#.#.#.#.#####.###.#.###.###.#.#,#.#...#.#.#.........#.....#...#.#.....#.#.#...#.#...#.#...#...#.....#.#...#...K.#,#.#.###.#.#########.#.#######.#.#########.###.#.###.#.#####.#.#.#######.#########,#.......#.#.......#h..#.....#.#.........#...#.#.....#.......#...#.....#.#...#...#,#.#######.#O#####.#######.#.#.#.#######.###.#.#.#######.#######.#.###F#.#.#.#.#.#,#.#....y..#...#...#.....#.#.#.#.#.#.....#...#.#.#.....#.#.....#...#.#.#...#.#.#.#,###.#####.###.#.###.###.#.###.#.#.#.###.#.#.#.###.###.#.#.###.#####.#.#.###.#.#.#,#...#.....#.#.#...#.#.Z.#...#.#.#.#.#...#.#.#.....#.#.#.#.#.#...#.....#...#...#.#,#.###.#####.#.###A#.#.###.#.#.#.#.#.#####.#########.#.#.#.#.###.#.#########.###.#,#.#.#.#.....#.#.#...#.#...#...#...#.....#.#.........#.#.#.#.#...#.#.......#.#...#,#.#.#.#####.#.#.#######.#########.#####.#.#.#####.#.#.#.#.#.#####.#.###.#.###.#.#,#.#.#...#...#.#...#.....#.....#.......#.#.#.#.#...#.#.#.#.#.....#.#.#...#.....#.#,#.#.###.#.#.#.###.#.#######.#.#####.###.#.#.#.#.#####.#.#.#.#.###.###.#########X#,#.#...#...#.#...#.#...#.....#.....#.#...#.....#.#...#.#.#.#.#...#...#.....#.....#,#.#W#.#####.###N#.###.#.#.#######.###.#.#######.#.#.#.###.#.###.###.#####.###.###,#i#.#.....#.#.#.#...#.#.#.#.....#.....#.#..r..#...#.#...#.#.#.....#.#...#...#.#.#,#.#######.#.#.#.#.###.###.#.###########.#.###.#.###.###.#.###.#####.#.#.###.#.#.#,#.......#...#.#.#...#...#.#.............#.#.#.#.#.#...#...#...#.....#.#.....#.#.#,#.#####.#.###.#.#.#.###.#.#.#############.#.#.#.#.###.#####.###.#####.#######.#.#,#.#.#...#.....#.#.#...#..t#...#.#.......#.#.#.#...#.....#.....#...#...#.....#.#.#,#.#.#.#######.#.#.###.#######.#.#.#.#####.#.#.#.###.###.#####.###.###.#.###.#.#.#,#...#.#...#...#.#...#.....#.#.#...#.....#.#.#.#.#...#.........#.#...#...T.#.#...#,###.#.#.#.#.###.###.#.###.#.#.#########.#.#.#.###.###########.#.###.#####.#.###.#,#...#...#.#.#...#...#...#...#.......#...#.#.#...#.#.....#...#...#...#...#.#...#.#,#.#######.###.###.#####.###########.#.###.#.###.#.#.###.#.#.###.#.###.#.#####.###,#.#...#v#...#.#.#.....#.........#...#...#.#.......#...#..l#...#.#.....#.....#.P.#,#.#.#.#.###.#.#.#####.#########.#.#####.#.###########.#######.#############.###.#,#...#.....#...#...............#.............................#....b..............#,#######################################.@.#######################################,#...#.#.........#.....#...........#...........#...#.....#.......#...#.....Q.#...#,#.#.#.#.#####.###.#.#.#.#####.###.#.###.#.###.#.#.#.###.#.#####.#.#.#.#.###.###.#,#.#.#.#.#...#.....#.#.#.#.#...#...#...#.#.#.....#.#...#...#.....#.#.#.#...#.#...#,#.#.#.#.#.#.#######.###.#.#.#####.###.#.#.#######.###.#####.#####.#.#.###.#.#.#.#,#.#...#.#.#.....#.#.#.B...#.....#.#...#.#.....#.....#.#...#.......#.#.#...#...#.#,#.#####.#.#####.#.#.#.#######.#.###.###.#.###.###.###.#.#####.#####.#.#.#######.#,#.#...#q#..f#.....#...#.....#.#...#.#...#.#.#...#.#.....#...#.#...#...#.#.....#.#,#.#.#.#.#.#.#######.###.###.###.#.#.#.###.#.###.###.#####.#.#.###.#####.#.###.#.#,#...#.#.#.#...#...#p..#.#.#...#.#...#...#.....#...#.#.....#.#.....#...#...#...#.#,#####.#.#####.#.#.###.#.#.###.#########.#####.###.#.#.#####.#####.###.#####.###.#,#.....#.......#.#.#...#.#...#.#.......#.#...#.#.#...#.#...#.....#.....#.#...#.#.#,#.###########.#.#.#####.###.#L#.#####R#.#.#.#.#.#####.#.#.#####.#####.#.#.###.#.#,#...........#.#.#.......#...#...#...#...#.#.#.....#...#.#.....#...#...#.#...#...#,#######.###.#.#.#########.#.#####.#.#######.#####.#.#######.#.###.#.###.###.###.#,#.......#...#.#.#.........#.......#.....#...#.....#.#.....#.#...#.#...#...#...#.#,#.#######.###.#.#.###.#################.#.###.#####.#.#.#.###.###.###.###.###.#.#,#.#.........#.#.#...#.............#.....#.........#.#.#.#.....#...#.#.......#.#.#,#.###.#######.#.###########.#####.#.###############.###.#####.#.###.#.#####.#.###,#...#.#.......#.#.........#.#...#.#.#...#.......#...#...#.#...#.#.....#...#.#...#,#.#G###.#######.#.#######.#.###.#.###.#.#.#####.#.###.###.#.###.#######.#.#####.#,#.#...#....x#.#.#.#z#.....#.....#.....#.#.....#...#...#...#.#...#.......#.#...#.#,#.###.#####.#.#.#.#.#########.#########.#####.#######.#.###.#####.#######.#.#.#.#,#k#.#.....#...#...#.#.....#...#.......#.#...#.#.......#.#...#.....#.#...#...#.#.#,#.#.#####.###.#####.#.###.#.###.#####.#.#.#.#.#.#.#####.#.###.#####.#.#.#####.#H#,#.#.....#...#.....#.#...#.#.#...#...#...#.#...#.#.#.....#.#...#...#...#...#.#.#.#,#.#.###.###.#####.#.###.#.#.#.###.#.###.#.#######.#.###.#.#.###.#.#.###.#Y#.#.#.#,#...#...#.#...#...#.....#..o#.#.#.#.....#.#.......#.#...#...#...#...#...#...#..g#,#####.###.#.###.#######.#####.#.#.#######.#####.###.###.#############.#####.###.#,#...#.#...#.....#.....#.....#.#.#...#...#.......#.....#...#...........#.#...#...#,#.#.#.###.#######.###.#######.#.###.#.###########.###.###.#.###########.#.###.###,#.#.#.#.....#.#.....#.#.......#...#.#...#...#...#...#.#...#.......#...#.I.#.#...#,#.#.#.#.###.#.#.###.#.#.#######.#.#.###.#.###.#.#.###.#.#########.###.#.###.###.#,#.#.#.#.#...#s....#.#.#.......#a#.#.....#.#...#.#.#...#.....#.....#...#.....#.#.#,#.###M#U###.#####.#.#.###.###.###.#####.#.#.###.#.#.#.#####.#.#####.#V#####.#.#.#,#.....#...#...#...#.#...#...#.#...#....n#.#...#d..#.#.#.J.#...#.....#...#..w#.#.#,#.#######.###.#####.###.#####.#.###.#####.###.#####.#.#.#.###.#####.#####.###.#.#,#.......#.#.#...#...#.#.....#.#...#.#...#...#.#.#...#.#.#.#...#...#...........#.#,#######.#.#.###E#.###.#####.#.#.#.#.###.#.###.#.#.#####.#.#####.#.#############.#,#.........#.......#.........C.#.#.......#.......#.......#.......#...............#,#################################################################################";
char end = 'z';

String[] inp = in.split(",");
char[][] map = new char[inp.length][inp[0].length()];
ArrayList<Path> paths = new ArrayList<Path>();
Map<String, Path> table = new HashMap<String, Path>();
Map<String, Boolean> DIJvisited = new HashMap<String, Boolean>();

void setup() {
  for (int i=0; i<map.length; i++) {
    for (int j=0; j<map[i].length; j++) {
      map[i][j] = inp[i].charAt(j);
    }
  }
  println("Task 1: "+steps("@"));
  setupFor2();
  println("Task 2: "+steps("1234"));
}

int steps(String start) {
  table.clear();
  paths.clear();
  for(int i=0;i<start.length();i++) {
    getPaths(start.charAt(i));
  }
  fillTable();
  
  PriorityQueue<DNode> DIJ2 = new PriorityQueue<DNode>();
  DIJ2.add(new DNode(start, start, 0));
  DIJvisited.clear();
  while (!DIJ2.isEmpty()) {
    DNode curr = DIJ2.poll();
    //println(curr.val+","+curr);
    if(DIJvisited.get(curr.visitedChars+","+curr.pos) != null) {
      continue;
    }
    //println(curr.val + " : "+curr);
    //println("from "+curr.visitedChars);
    DIJvisited.put(curr.visitedChars+","+curr.pos, true);
    //println(curr.val+" : "+curr.visitedChars);
    if (curr.visitedChars.length()==end-'a'+1+curr.pos.length()) {
      return curr.val;
    }
    for (int a=0; a<curr.pos.length(); a++) {
      for (char i='a'; i<=end; i++) {
        if (curr.pos.contains(i+"") || curr.visitedChars.contains(""+i)) {
          continue;
        }
        Path p = table.get(curr.pos.charAt(a)+","+i);
        if(p==null) {
          continue;
        }
        if (p.available(curr.visitedChars)) {
          DNode n = new DNode(curr.visitedChars+i, curr.pos.replaceAll(""+curr.pos.charAt(a),""+i), p.len+curr.val);
          if (DIJvisited.get(n.visitedChars+","+n.pos)==null) {
            DIJ2.add(n);
            //println("  to "+n.visitedChars+"   at inde "+a);
          }
        }
      }
    }
  }
  return -1;
}

void getPaths(char player) {
  for (char n = 'a'; n <= end; n++) {
    Path p = BFS(map, getPosOf(map, player), getPosOf(map, n));
    if (!paths.contains(p) && p.len!=-1) {
      paths.add(p);
    }
    for (char m = 'a'; m <= end; m++) {
      if (m != n) {
        Path l = BFS(map, getPosOf(map, m), getPosOf(map, n));
        if (!paths.contains(l)&& p.len!=-1) {
          paths.add(l);
        }
      }
    }
  }
}

void fillTable() {
  for (int i=0; i<paths.size(); i++) {
    Path p = paths.get(i);
    //println(p);
    table.put(p.p1.val+","+p.p2.val, p);
    table.put(p.p2.val+","+p.p1.val, p);
  }
}

void setupFor2() {
  map[40][40]= '#';
  map[41][40]= '#';
  map[39][40]= '#';
  map[40][41]= '#';
  map[40][39]= '#';
  map[39][39]= '1';
  map[39][41]= '2';
  map[41][39]= '3';
  map[41][41]= '4';
}

Point getPosOf(char[][] map, char c) {
  for (int i=0; i<map.length; i++) {
    for (int j=0; j<map[i].length; j++) {
      if (map[i][j]==c) {
        return new Point(i, j, c);
      }
    }
  }
  return new Point(-1, -1, c);
}

class DNode implements Comparable<DNode> {
  String name;
  List<DNode> shortestPath = new LinkedList<DNode>();
  String visitedChars;
  String pos;
  int val;
  boolean visited = false;

  public DNode(String v, String p, int va) {
    char[] chars = v.toCharArray();
    Arrays.sort(chars);
    visitedChars = new String(chars);
    pos = p;
    val = va;
  }

  boolean equals(Object o) {
    DNode d = (DNode)o;
    return (d.visitedChars.equals(visitedChars) && d.pos.equals(pos) && val>d.val);
  }

  String toString() {
    return "("+visitedChars+"|"+pos+") : "+val;
  }

  int compareTo(DNode n) {
    return val-n.val;
  }
}

class Path {
  Point p1;
  Point p2;
  ArrayList<Character> keys;
  int len;

  public Path(Point p1, Point p2, ArrayList<Character> keys, int len) {
    this.p1 = p1;
    this.p2 = p2;
    this.keys = keys;
    this.len = len;
  }

  boolean keyReq(char k) {
    return keys.contains(k);
  }

  boolean equals(Object o) {
    Path p = (Path)o;
    return (p1.equals(p.p1) && p2.equals(p.p2)) || (p1.equals(p.p2) && p2.equals(p.p1));
  }

  String toString() {
    return "( "+p1+" | "+p2+" ) len: "+len+" with"+keys+"\n";
  }

  boolean available(String s) {
    for (char k : keys) {
      if (!s.contains((char)(k+32)+"")) {
        return false;
      }
    }
    return true;
  }
}

class Point { 
  int x; 
  int y; 
  char val = '_';

  public Point(int x, int y) { 
    this.x = x; 
    this.y = y;
  }

  public Point(int x, int y, char val) { 
    this.x = x; 
    this.y = y;
    this.val = val;
  }

  String toString() {
    return "["+x+","+y+"]"+((val == '_')?"":""+val);
  }

  boolean equals(Object o) {
    Point p = (Point)o;
    return x==p.x && y==p.y;
  }
}

int getDist(char[][] map, Point s, Point f) {  
  Path p = BFS(map, s, f);
  println("keys to "+p.keys);
  return BFS(map, s, f).len;
} 

int ROW = 100; 
int COL = 100; 

class queueNode { 
  Point pt;
  int dist;
  ArrayList<Character> doors = new ArrayList<Character>();

  public queueNode(Point pt, int dist, queueNode prev) { 
    this.pt = pt; 
    this.dist = dist;
    if (prev != null) {
      for (char c : prev.doors) {
        doors.add(c);
      }
    }
  }

  void addDoor(char c) {
    doors.add(c);
  }
}

boolean isValid(int row, int col) { 
  return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL);
} 

int rowNum[] = {-1, 0, 0, 1}; 
int colNum[] = {0, -1, 1, 0}; 

Path BFS(char mat[][], Point src, Point dest) { 
  if (mat[src.x][src.y] == '#' || mat[dest.x][dest.y] == '#') {
    return new Path(new Point(-1, -1), new Point(-1, -1), new ArrayList<Character>(), -1);
  }
  boolean [][]visited = new boolean[ROW][COL];
  visited[src.x][src.y] = true; 
  Queue<queueNode> q = new LinkedList<queueNode>(); 
  queueNode s = new queueNode(src, 0, null); 
  q.add(s);
  while (!q.isEmpty()) { 
    queueNode curr = q.peek(); 
    Point pt = curr.pt; 
    if (pt.x == dest.x && pt.y == dest.y) {
      return new Path(src, dest, curr.doors, curr.dist);
    }
    q.remove(); 
    for (int i = 0; i < 4; i++) { 
      int row = pt.x + rowNum[i]; 
      int col = pt.y + colNum[i]; 
      if (isValid(row, col) &&  mat[row][col] != '#' &&  !visited[row][col]) { 
        visited[row][col] = true; 
        queueNode Adjcell = new queueNode(new Point(row, col), curr.dist + 1, curr); 
        if (mat[row][col] >= 'A' && mat[row][col] <= 'Z') {
          Adjcell.addDoor(mat[row][col]);
        }
        q.add(Adjcell);
      }
    }
  } 
  return new Path(new Point(-1, -1), new Point(-1, -1), new ArrayList<Character>(), -1);
}
